我修正了`generate_lval_address`函数，并且测试了一个简单的文件`array.c`
```c
int main()
{
	int a[10][2] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	int sum;
	int i, j;

	i = 0;
	sum = 0;
	while (i < 10)
	{
		j = 0;
		while (j < 2)
		{
			sum = sum + a[i][j];
			j = j + 1;
		}
		i = i + 2;
	}
	return sum;
}

```
生成的IR表示为:
```IR

define dso_local i32 @main() #0 {
entry:
  %1 = alloca [10 x [2 x ]]i32
  ; aggregate initializer not fully implemented
  %2 = alloca i32
  %3 = alloca i32
  %4 = alloca i32
  store i32 0, i32* %3
  store i32 0, i32* %2
  br label %while_cond1
while_cond1:
  %5 = load i32, i32* %3
  %6 = icmp i32 %5, 10
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %while_body2, label %while_after3
while_body2:
  store i32 0, i32* %4
  br label %while_cond4
while_cond4:
  %8 = load i32, i32* %4
  %9 = icmp i32 %8, 2
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %while_body5, label %while_after6
while_body5:
  %11 = load i32, i32* %2
  %12 = load i32, i32* %3
 %13 = getelementptr inbounds i32, i32* %1, i32 %12
  %14 = load i32, i32* %4
 %15 = getelementptr inbounds i32, i32* %13, i32 %14
  %16 = load i32, i32* %15
  %17 = add i32 %11, %16
  store i32 %17, i32* %2
  %18 = load i32, i32* %4
  %19 = add i32 %18, 1
  store i32 %19, i32* %4
  br label %while_cond4
while_after6:
  %20 = load i32, i32* %3
  %21 = add i32 %20, 2
  store i32 %21, i32* %3
  br label %while_cond1
while_after3:
  %22 = load i32, i32* %2
  ret i32 %22
}
```
当我使用LLVM LLI测试这个IR时，出现了错误:
```bash
❯❯❯ lli ll/array.ll                                                        (0s)[16:14:46]
lli: lli: ll/array.ll:4:26: error: expected type
  %1 = alloca [10 x [2 x ]]i32
                         ^
```
这似乎是因为生成数组的`alloca`指令时，出现了错误，没有指定元素类型。请根据之前的代码进一步分析在`ir.c`中为什么会出现这个错误，并且给出解决方案