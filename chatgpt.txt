`ir.c`片段
```c
    if (strcmp(node->name, "FuncDef") == 0)
    {
        char *return_type_str = get_type_str(node->children[0]);
        char *func_name = node->children[1]->name;
        Node *params_opt_node = node->children[2];
        Node *block_node = node->children[3];

        TypeNode *params_list_head = NULL;
        if (params_opt_node->num_children > 0)
            process_param_types(params_opt_node->children[0], &params_list_head);

        char signature[1024] = "";
        for (TypeNode *p = params_list_head; p; p = p->next)
        {
            strcat(signature, p->type);
            if (p->next)
                strcat(signature, ", ");
        }

        add_symbol_func(func_name, return_type_str, params_list_head);
        generator.current_func_ret_type = return_type_str;
        generator.last_instr_is_terminator = 0;
        emit("\ndefine dso_local %s @%s(%s) #0 {", return_type_str, func_name, signature);
        emit("entry:");

        enter_scope();
        int param_count = 0;
        if (params_opt_node->num_children > 0)
        {
            process_formal_params(params_opt_node->children[0], &param_count);
        }
        generator.reg_counter = param_count - 1;
        generate_code(block_node);
        exit_scope();

        if (!generator.last_instr_is_terminator)
        {
            if (strcmp(return_type_str, "void") == 0)
                emit("\tret void");
            else
                emit("\tret %s 0", return_type_str);
        }
        emit("}");
        return NULL;
    }
```
对于第四个问题，我加入了重置寄存器的代码，然而生成的`func.ll`中`square`函数寄存器依然是从1开始，这是什么情况?
其次我还遇到了很多类型的问题，例如
```bash
lli: lli: ll/array.ll:15:19: error: '%5' defined with type 'i1' but expected 'i32'
        %6 = icmp ne i32 %5, 0
```
其中`array.ll`内容为:
```ll

define dso_local i32 @main() #0 {
entry:
 %0 = alloca [10 x [2 x i32]]
	store [10 x [2 x i32]] zeroinitializer, [10 x [2 x i32]]* %0
 %1 = alloca i32
 %2 = alloca i32
 %3 = alloca i32
	store i32 0, i32* %2
	store i32 0, i32* %1
	br label %while_cond1
while_cond1:
	%4 = load i32, i32* %2
	%5 = icmp slt i32 %4, 10
	%6 = icmp ne i32 %5, 0
	br i1 %6, label %while_body2, label %while_after3
while_body2:
	store i32 0, i32* %3
	br label %while_cond4
while_cond4:
	%7 = load i32, i32* %3
	%8 = icmp slt i32 %7, 2
	%9 = icmp ne i32 %8, 0
	br i1 %9, label %while_body5, label %while_after6
while_body5:
	%10 = load i32, i32* %1
	%11 = load i32, i32* %2
 %12 = getelementptr i32, i32* %0, i32 %11
	%13 = load i32, i32* %3
 %14 = getelementptr i32, i32* %12, i32 %13
	%15 = load i32, i32* %14
	%16 = add i32 %10, %15
	store i32 %16, i32* %1
	%17 = load i32, i32* %3
	%18 = add i32 %17, 1
	store i32 %18, i32* %3
	br label %while_cond4
while_after6:
	%19 = load i32, i32* %2
	%20 = add i32 %19, 2
	store i32 %20, i32* %2
	br label %while_cond1
while_after3:
	%21 = load i32, i32* %1
	ret i32 %21
}
```
似乎是因为`i1`与`i32`不兼容，如果我需要能够实现类型自动扩展，例如把`i1`能够扩展为`i32`，`i32`扩展为`float`，如果需要的时候，我应该怎么做?