很好，现在生成的有关数组初始化的指令已经没问题，然而当我启动测试时，出现了新的问题:
```bash
❯❯❯ make test                                                       (1s)[20:38:00]
flex -o lex.yy.c sysy.l
bison -d  sysy.y
gcc -g node.c sysy.tab.c lex.yy.c ir.c -o exe/sysy_complier
lli: lli: ll/array.ll:14:13: error: expected icmp predicate (e.g. 'eq')
  %6 = icmp i32 %5, 10
            ^

lli: lli: ll/break.ll:11:13: error: expected icmp predicate (e.g. 'eq')
  %4 = icmp i32 %3, 10
            ^

lli: lli: ll/continue.ll:11:13: error: expected icmp predicate (e.g. 'eq')
  %4 = icmp i32 %3, 10
            ^

lli: lli: ll/float.ll:6:15: error: floating point constant invalid for type
  store float 1.732, float* %1
              ^

lli: lli: ll/func.ll:4:3: error: instruction expected to be numbered '%2' or greater
  %1 = alloca i32
  ^

lli: lli: ll/if.ll:13:13: error: expected icmp predicate (e.g. 'eq')
  %7 = icmp i32 %5, %6
            ^

lli: lli: ll/if_while.ll:14:13: error: expected icmp predicate (e.g. 'eq')
  %9 = icmp i32 %5, %8
            ^

lli: lli: ll/myarray.ll:1:7: error: expected 'type' after '='
 %1 = alloca [4 x [2 x i32]]
      ^

lli: lli: ll/while.ll:11:13: error: expected icmp predicate (e.g. 'eq')
  %4 = icmp i32 %3, 10
            ^

lli: lli: ll/while_if.ll:12:13: error: expected icmp predicate (e.g. 'eq')
  %5 = icmp i32 %4, 9527
            ^

make: *** [Makefile:11：test] 错误 1
```
我查看了一些生成的具体结构，例如`array.ll`:
```ll

define dso_local i32 @main() #0 {
entry:
 %1 = alloca [10 x [2 x i32]]
  store [10 x [2 x i32]] zeroinitializer, [10 x [2 x i32]]* %1
 %2 = alloca i32
 %3 = alloca i32
 %4 = alloca i32
  store i32 0, i32* %3
  store i32 0, i32* %2
  br label %while_cond1
while_cond1:
  %5 = load i32, i32* %3
  %6 = icmp i32 %5, 10
  %7 = icmp ne i32 %6, 0
  br i1 %7, label %while_body2, label %while_after3
while_body2:
  store i32 0, i32* %4
  br label %while_cond4
while_cond4:
  %8 = load i32, i32* %4
  %9 = icmp i32 %8, 2
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %while_body5, label %while_after6
while_body5:
  %11 = load i32, i32* %2
  %12 = load i32, i32* %3
 %13 = getelementptr i32, i32* %1, i32 %12
  %14 = load i32, i32* %4
 %15 = getelementptr i32, i32* %13, i32 %14
  %16 = load i32, i32* %15
  %17 = add i32 %11, %16
  store i32 %17, i32* %2
  %18 = load i32, i32* %4
  %19 = add i32 %18, 1
  store i32 %19, i32* %4
  br label %while_cond4
while_after6:
  %20 = load i32, i32* %3
  %21 = add i32 %20, 2
  store i32 %21, i32* %3
  br label %while_cond1
while_after3:
  %22 = load i32, i32* %2
  ret i32 %22
}
```
或者是`if_while.ll`
```ll

define dso_local i32 @main() #0 {
entry:
 %1 = alloca i32
 %2 = alloca i32
 %3 = alloca i32
 %4 = alloca i32
  store i32 1, i32* %1
  store i32 2, i32* %2
  %5 = load i32, i32* %2
  %6 = load i32, i32* %1
  %7 = mul i32 %6, 2
  %8 = add i32 %7, 4
  %9 = icmp i32 %5, %8
  %10 = icmp ne i32 %9, 0
  br i1 %10, label %if_then1, label %if_else2
if_then1:
  store i32 0, i32* %3
  br label %while_cond4
while_cond4:
  %11 = load i32, i32* %3
  %12 = icmp i32 %11, 10
  %13 = icmp ne i32 %12, 0
  br i1 %13, label %while_body5, label %while_after6
while_body5:
  %14 = load i32, i32* %4
  %15 = load i32, i32* %3
  %16 = mul i32 %15, 2
  %17 = add i32 %14, %16
  store i32 %17, i32* %4
  %18 = load i32, i32* %3
  %19 = add i32 %18, 1
  store i32 %19, i32* %3
  br label %while_cond4
while_after6:
  br label %if_merge3
if_else2:
  store i32 100, i32* %4
  br label %if_merge3
if_merge3:
  %20 = load i32, i32* %4
  ret i32 %20
}
```
这似乎是因为没有有些`icmp`缺少判断符号导致的。
而`myarray.ll`文件内容如下:
```ll
 %1 = alloca [4 x [2 x i32]]
  store [4 x [2 x i32]] zeroinitializer, [4 x [2 x i32]]* %1
 %2 = alloca [4 x [2 x i32]]
  store [4 x [2 x i32]] zeroinitializer, [4 x [2 x i32]]* %2
 %3 = alloca [4 x [2 x i32]]
  store [4 x [2 x i32]] zeroinitializer, [4 x [2 x i32]]* %3
 %4 = alloca [4 x [2 x i32]]
  store [4 x [2 x i32]] zeroinitializer, [4 x [2 x i32]]* %4

```

请根据生成的代码，和以下`ir.c`，分析问题的原因，并且给出解决方案
```c
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ir.h"
#include "sysy.tab.h"

// 用于表示函数参数类型列表的节点
typedef struct TypeNode
{
    char *type;
    struct TypeNode *next;
} TypeNode;

typedef struct Symbol
{
    char *name;
    char *type;     // 变量类型 或 函数返回类型
    char *llvm_reg; // 变量在栈上的地址指针
    int is_const;
    int is_func;      // 新增：是否是函数
    TypeNode *params; // 新增：函数参数类型列表
    struct Symbol *next;
} Symbol;

typedef struct Scope
{
    Symbol *head;         // 作用域内符号链表头
    struct Scope *parent; // 父作用域指针
} Scope;

typedef struct
{
    int reg_counter;              // 当前寄存器使用个数
    int label_counter;            // 当前标签使用个数
    char **code_buffer;           // IR代码缓冲区
    int code_size;                // 当前代码行数
    int code_capacity;            // 缓冲区容量
    Scope *current_scope;         // 当前作用域
    char *current_func_ret_type;  // 当前函数的返回类型
    int last_instr_is_terminator; // 上一个指令是否是终结指令 (如ret, br等)
} IRGenerator;
static IRGenerator generator;

static char *get_type_str(Node *type_node);
static char *generate_lval_address(Node *node);
static void emit(const char *format, ...);
static void get_dimensions(Node *dim_node, int *dims, int *num_dims);
static void generate_initializer_stores(Node *init_node, char *base_ptr, char *llvm_type, int *dims, int num_dims, int *flat_index);

// 符号表管理
static void enter_scope()
{
    Scope *new_scope = (Scope *)malloc(sizeof(Scope));
    new_scope->head = NULL;
    new_scope->parent = generator.current_scope;
    generator.current_scope = new_scope;
}

static void exit_scope()
{
    if (generator.current_scope)
    {
        Scope *parent_scope = generator.current_scope->parent;
        Symbol *current = generator.current_scope->head;
        while (current)
        {
            Symbol *next = current->next;
            free(current->name);
            free(current->type);
            free(current->llvm_reg);
            free(current);
            current = next;
        }
        free(generator.current_scope);
        generator.current_scope = parent_scope;
    }
}

static void add_symbol_func(const char *name, const char *type,
                            TypeNode *params)
{
    Symbol *new_symbol = (Symbol *)malloc(sizeof(Symbol));
    new_symbol->name = strdup(name);
    new_symbol->type = strdup(type);
    new_symbol->llvm_reg = NULL; // 函数没有栈地址
    new_symbol->is_const = 0;
    new_symbol->is_func = 1;     // 标记为函数
    new_symbol->params = params; // 挂载参数类型列表
    new_symbol->next = generator.current_scope->head;
    generator.current_scope->head = new_symbol;
}

static void add_symbol(const char *name, const char *type, const char *llvm_reg,
                       int is_const)
{
    Symbol *new_symbol = (Symbol *)malloc(sizeof(Symbol));
    new_symbol->name = strdup(name);
    new_symbol->type = strdup(type);
    new_symbol->llvm_reg = strdup(llvm_reg);
    new_symbol->is_const = is_const;
    new_symbol->is_func = 0; // 标记为变量
    new_symbol->params = NULL;
    new_symbol->next = generator.current_scope->head;
    generator.current_scope->head = new_symbol;
}

static Symbol *lookup_symbol(const char *name)
{
    Scope *scope = generator.current_scope;
    while (scope)
    {
        Symbol *sym = scope->head;
        while (sym)
        {
            if (strcmp(sym->name, name) == 0)
            {
                return sym;
            }
            sym = sym->next;
        }
        scope = scope->parent;
    }
    return NULL;
}

static char *new_reg()
{
    static char buf[16];
    sprintf(buf, "%%%d", ++generator.reg_counter);
    return strdup(buf);
}

static char *new_label(const char *prefix)
{
    static char buf[32];
    sprintf(buf, "%s%d", prefix, ++generator.label_counter);
    return strdup(buf);
}

static char *get_btype(Node *btype_node)
{
    if (btype_node && btype_node->num_children > 0)
    {
        Node *type_token = btype_node->children[0];
        if (strcmp(type_token->name, "int") == 0)
            return "i32";
        if (strcmp(type_token->name, "float") == 0)
            return "float";
    }
    return "void";
}

static void process_param_types(Node *n, TypeNode **head_ref);
static void process_formal_params(Node *n, int *count);
static void process_actual_params(Node *n, char *arg_reg_list[], int *count);
static void process_var_def_list(Node *n, const char *type);
static void process_block_item_list(Node *n);
static char *generate_code(Node *node)
{
    if (!node || (node->name == NULL && node->num_children == 0))
        return NULL;

    // --- 结构与作用域 ---
    if (strcmp(node->name, "CompUnit") == 0)
    {
        if (node->num_children > 0)
        {
            generate_code(node->children[0]);
            generate_code(node->children[1]);
        }
        return NULL;
    }
    if (strcmp(node->name, "Block") == 0)
    {
        enter_scope();
        process_block_item_list(node->children[0]);
        exit_scope();
        return NULL;
    }

    // --- 声明 ---
    if (strcmp(node->name, "VarDecl") == 0 || strcmp(node->name, "ConstDecl") == 0)
    {
        char *type = get_type_str(node->children[0]);
        process_var_def_list(node->children[1], type);
        return NULL;
    }

    // --- 函数定义 ---
    if (strcmp(node->name, "FuncDef") == 0)
    {
        char *return_type_str = get_type_str(node->children[0]);
        char *func_name = node->children[1]->name;
        Node *params_opt_node = node->children[2];
        Node *block_node = node->children[3];

        TypeNode *params_list_head = NULL;
        if (params_opt_node->num_children > 0)
            process_param_types(params_opt_node->children[0], &params_list_head);

        char signature[1024] = "";
        for (TypeNode *p = params_list_head; p; p = p->next)
        {
            strcat(signature, p->type);
            if (p->next)
                strcat(signature, ", ");
        }

        add_symbol_func(func_name, return_type_str, params_list_head);
        generator.current_func_ret_type = return_type_str;
        generator.last_instr_is_terminator = 0;
        emit("\ndefine dso_local %s @%s(%s) #0 {", return_type_str, func_name, signature);
        emit("entry:");

        enter_scope();
        int param_count = 0;
        if (params_opt_node->num_children > 0)
            process_formal_params(params_opt_node->children[0], &param_count);
        generate_code(block_node);
        exit_scope();

        if (!generator.last_instr_is_terminator)
        {
            if (strcmp(return_type_str, "void") == 0)
                emit("  ret void");
            else
                emit("  ret %s 0", return_type_str);
        }
        emit("}");
        return NULL;
    }

    // --- 语句 ---
    if (strcmp(node->name, "AssignStmt") == 0)
    {
        char *val_reg = generate_code(node->children[1]);
        char *ptr_reg = generate_lval_address(node->children[0]);

        // 为了获取类型，我们需要找到LVal最终指向的变量
        Node *base_var_node = node->children[0];
        while (strcmp(base_var_node->name, "ArrayAccess") == 0)
        {
            base_var_node = base_var_node->children[0];
        }
        Symbol *sym = lookup_symbol(base_var_node->children[0]->name);

        char element_type[64] = "i32";
        if (sym)
        {
            // 从数组类型 [10 x i32] 中提取元素类型 i32
            char *type_start = strchr(sym->type, 'x');
            if (type_start)
            {
                sscanf(type_start + 1, " %s", element_type);
                element_type[strlen(element_type) - 1] = '\0'; // 去掉 ']'
            }
            else
            {
                strcpy(element_type, sym->type);
            }
        }

        emit("  store %s %s, %s* %s", element_type, val_reg, element_type, ptr_reg);
        free(val_reg);
        free(ptr_reg);
        return NULL;
    }
    if (strcmp(node->name, "ReturnStmt") == 0)
    {
        Node *exp_opt_node = node->children[0];
        if (exp_opt_node->num_children > 0)
        {
            char *ret_val_reg = generate_code(exp_opt_node->children[0]);
            emit("  ret %s %s", generator.current_func_ret_type, ret_val_reg);
            free(ret_val_reg);
        }
        else
        {
            emit("  ret void");
        }
        generator.last_instr_is_terminator = 1;
        return NULL;
    }
    if (strcmp(node->name, "IfStmt") == 0 || strcmp(node->name, "IfElseStmt") == 0)
    {
        char *cond_reg = generate_code(node->children[0]);
        char *i1_cond_reg = new_reg();
        emit("  %s = icmp ne i32 %s, 0", i1_cond_reg, cond_reg);
        free(cond_reg);
        char *then_label = new_label("if_then"), *else_label = new_label("if_else"), *merge_label = new_label("if_merge");
        if (strcmp(node->name, "IfElseStmt") == 0)
        {
            emit("  br i1 %s, label %%%s, label %%%s", i1_cond_reg, then_label, else_label);
            emit("%s:", then_label);
            generate_code(node->children[1]);
            if (!generator.last_instr_is_terminator)
                emit("  br label %%%s", merge_label);
            emit("%s:", else_label);
            generate_code(node->children[2]);
        }
        else
        {
            emit("  br i1 %s, label %%%s, label %%%s", i1_cond_reg, then_label, merge_label);
            emit("%s:", then_label);
            generate_code(node->children[1]);
        }
        if (!generator.last_instr_is_terminator)
            emit("  br label %%%s", merge_label);
        emit("%s:", merge_label);
        generator.last_instr_is_terminator = 0;
        free(i1_cond_reg);
        free(then_label);
        free(else_label);
        free(merge_label);
        return NULL;
    }
    if (strcmp(node->name, "WhileStmt") == 0)
    {
        char *cond_label = new_label("while_cond"), *body_label = new_label("while_body"), *after_label = new_label("while_after");
        emit("  br label %%%s", cond_label);
        emit("%s:", cond_label);
        char *cond_reg = generate_code(node->children[0]);
        char *i1_cond_reg = new_reg();
        emit("  %s = icmp ne i32 %s, 0", i1_cond_reg, cond_reg);
        free(cond_reg);
        emit("  br i1 %s, label %%%s, label %%%s", i1_cond_reg, body_label, after_label);
        emit("%s:", body_label);
        generate_code(node->children[1]);
        if (!generator.last_instr_is_terminator)
            emit("  br label %%%s", cond_label);
        emit("%s:", after_label);
        generator.last_instr_is_terminator = 0;
        free(i1_cond_reg);
        free(cond_label);
        free(body_label);
        free(after_label);
        return NULL;
    }
    if (strcmp(node->name, "ExpStmt") == 0)
    {
        if (node->children[0]->num_children > 0)
            generate_code(node->children[0]->children[0]);
        return NULL;
    }
    // --- 表达式 ---
    if (strcmp(node->name, "BinaryOp") == 0)
    {
        char *op_str = node->children[0]->name;
        char *left_reg = generate_code(node->children[1]);
        char *right_reg = generate_code(node->children[2]);
        char *res_reg = new_reg();
        char *type = "i32";
        char *op_code = "";
        int is_cmp = 0;
        if (strcmp(op_str, "+") == 0)
            op_code = "add";
        else if (strcmp(op_str, "-") == 0)
            op_code = "sub";
        else if (strcmp(op_str, "*") == 0)
            op_code = "mul";
        else if (strcmp(op_str, "/") == 0)
            op_code = "sdiv";
        else if (strcmp(op_str, "%") == 0)
            op_code = "srem";
        else
        {
            is_cmp = 1;
            if (strcmp(op_str, "==") == 0)
                op_code = "eq";
            else if (strcmp(op_str, "!=") == 0)
                op_code = "ne";
            else if (strcmp(op_str, "<") == 0)
                op_code = "slt";
            else if (strcmp(op_str, ">") == 0)
                op_code = "sgt";
            else if (strcmp(op_str, "<=") == 0)
                op_code = "sle";
            else if (strcmp(op_str, ">=") == 0)
                op_code = "sge";
        }
        emit("  %s = %s %s %s, %s", res_reg, is_cmp ? "icmp" : op_code, type, left_reg, right_reg);
        free(left_reg);
        free(right_reg);
        return res_reg;
    }
    if (strcmp(node->name, "FuncCall") == 0)
    {
        char *func_name = node->children[0]->name;
        Symbol *func_sym = lookup_symbol(func_name);
        if (!func_sym || !func_sym->is_func)
        {
            fprintf(stderr, "Error: Call to undefined function '%s'\n", func_name);
            exit(1);
        }
        char *arg_reg_list[32];
        int arg_count = 0;
        if (node->children[1]->num_children > 0)
            process_actual_params(node->children[1]->children[0], arg_reg_list, &arg_count);
        char args_final_str[1024] = "";
        TypeNode *p = func_sym->params;
        for (int i = 0; i < arg_count; i++, p = p->next)
        {
            if (!p)
            {
                fprintf(stderr, "Error: Too many arguments for function %s\n", func_name);
                exit(1);
            }
            strcat(args_final_str, p->type);
            strcat(args_final_str, " ");
            strcat(args_final_str, arg_reg_list[i]);
            if (i < arg_count - 1)
                strcat(args_final_str, ", ");
            free(arg_reg_list[i]);
        }
        if (strcmp(func_sym->type, "void") == 0)
        {
            emit("  call void @%s(%s)", func_name, args_final_str);
            return NULL;
        }
        else
        {
            char *res_reg = new_reg();
            emit("  %s = call %s @%s(%s)", res_reg, func_sym->type, func_name, args_final_str);
            return res_reg;
        }
    }
    if (strcmp(node->name, "UnaryOp") == 0)
    {
        char *operand_reg = generate_code(node->children[1]);
        char *op_str = node->children[0]->name;

        if (strcmp(op_str, "+") == 0)
        {
            return operand_reg; // 正号是无操作
        }
        else if (strcmp(op_str, "-") == 0)
        {
            char *res_reg = new_reg();
            emit("  %s = sub i32 0, %s", res_reg, operand_reg);
            free(operand_reg);
            return res_reg;
        }
        else if (strcmp(op_str, "!") == 0)
        {
            char *cmp_reg = new_reg();
            emit("  %s = icmp eq i32 %s, 0", cmp_reg, operand_reg);
            char *res_reg = new_reg();
            emit("  %s = zext i1 %s to i32", res_reg, cmp_reg);
            free(operand_reg);
            free(cmp_reg);
            return res_reg;
        }
    }
    // 数组初始化，安全处理以防崩溃
    if (strcmp(node->name, "InitVal_Aggregate") == 0)
    {
        emit("  ; aggregate initializer not fully implemented");
        return strdup("0"); // 返回一个哑元值
    }

    // LVal作为右值使用
    if (strcmp(node->name, "ArrayAccess") == 0 || (strcmp(node->name, "LVal") == 0 && node->num_children == 1))
    {
        char *ptr_reg = generate_lval_address(node);
        char *val_reg = new_reg();
        char element_type[64] = "i32"; // 简化
        emit("  %s = load %s, %s* %s", val_reg, element_type, element_type, ptr_reg);
        free(ptr_reg);
        return val_reg;
    }

    if (node->num_children == 0)
    { // 叶子节点: INCONST, IDENT
        Symbol *sym = lookup_symbol(node->name);
        if (sym && !sym->is_func)
        { // 这是一个已声明的变量
            char *val_reg = new_reg();
            emit("  %s = load %s, %s* %s", val_reg, sym->type, sym->type, sym->llvm_reg);
            return val_reg;
        }
        return strdup(node->name); // 否则是数字字面量或函数名
    }

    if (node->num_children == 1)
    {
        return generate_code(node->children[0]);
    }

    return NULL; // 其他所有情况
}

/* ================================================================== */
/* 辅助函数 (Helpers)                                           */
/* ================================================================== */
// get_type_str: 从类型节点获取LLVM类型字符串
static char *get_type_str(Node *type_node)
{
    if (strcmp(type_node->name, "int") == 0)
        return "i32";
    if (strcmp(type_node->name, "float") == 0)
        return "float";
    return "void";
}

// generate_lval_address: 为左值(LVal)生成地址
static char *generate_lval_address(Node *node)
{
    // 基准情形：一个简单的变量 (e.g., "a")
    // AST 结构是 LVal -> IDENT("a")
    if (strcmp(node->name, "LVal") == 0)

    {
        // LVal 节点的孩子才是真正的标识符节点
        Node *ident_node = node->children[0];
        Symbol *sym = lookup_symbol(ident_node->name);
        if (sym)

        {
            // 确保找到的是变量而不是函数
            if (sym->is_func)
            {
                fprintf(stderr, "FATAL: Cannot take address of function '%s'.\n", ident_node->name);
                exit(1);
            }
            return strdup(sym->llvm_reg);
        }
        fprintf(stderr, "FATAL: Undefined symbol '%s' used as LVal.\n", ident_node->name);
        exit(1);
    }

    if (strcmp(node->name, "ArrayAccess") == 0)
    {
        // 递归调用以获取数组或子数组的基地址
        char *base_ptr_reg = generate_lval_address(node->children[0]);
        char *index_val_reg = generate_code(node->children[1]);
        char *res_ptr_reg = new_reg();
        emit(" %s = getelementptr i32, i32* %s, i32 %s", res_ptr_reg, base_ptr_reg, index_val_reg);
        free(base_ptr_reg);
        free(index_val_reg);
        return res_ptr_reg;
    }

    fprintf(stderr, "FATAL: generate_lval_address called with unexpected node type '%s'.\n", node->name);
    exit(1);
    return NULL; // 永不执行
}
// build_array_type_str: 递归构建数组类型字符串
static void build_array_type_str(Node *dim_node, char *type_str_builder)
{
    if (!dim_node || dim_node->num_children == 0)
        return;
    char *const_val_str = generate_code(dim_node->children[0]);
    char temp[64];
    sprintf(temp, "[%s x ", const_val_str);
    strcat(type_str_builder, temp);
    free(const_val_str);
    build_array_type_str(dim_node->children[1], type_str_builder);
    strcat(type_str_builder, "]");
}

static char *build_llvm_type_str(Node *dim_node, const char *base_type)
{
    // 基准情形：没有更多维度了，返回当前构建的类型
    if (!dim_node || dim_node->num_children == 0)
    {
        return strdup(base_type);
    }

    // 递归步骤：先为内部维度构建类型
    // dim_node->children[1] 是剩余的维度列表
    char *inner_type = build_llvm_type_str(dim_node->children[1], base_type);

    // 获取当前维度的尺寸
    char *dim_size_str = generate_code(dim_node->children[0]);

    // 构建当前维度的类型字符串
    char result_buf[512];
    sprintf(result_buf, "[%s x %s]", dim_size_str, inner_type);

    // 释放中间结果
    free(inner_type);
    free(dim_size_str);

    return strdup(result_buf);
}

// process_var_def_list: 健壮的、递归处理变量定义列表的函数
static void process_var_def_list(Node *n, const char *base_type)
{
    if (!n || n->num_children == 0)
        return;

    Node *var_def_node = n->children[0];
    char *var_name = var_def_node->children[0]->name;
    Node *dim_list_node = var_def_node->children[1];

    char *llvm_type = build_llvm_type_str(dim_list_node, base_type);

    char *ptr_reg = new_reg();
    emit(" %s = alloca %s", ptr_reg, llvm_type);
    add_symbol(var_name, llvm_type, ptr_reg, 0);

    // --- 初始化逻辑 ---
    // 无论是部分初始化还是不初始化，都先全部置零
    if (dim_list_node->num_children > 0)
    { // 仅对数组进行
        emit("  store %s zeroinitializer, %s* %s", llvm_type, llvm_type, ptr_reg);
    }

    if (strcmp(var_def_node->name, "VarDef_Init") == 0)
    {
        Node *init_val_node = var_def_node->children[2];

        // 检查是聚合初始化还是简单变量初始化
        if (dim_list_node->num_children > 0)
        {                 // 数组聚合初始化
            int dims[10]; // 最多支持10维
            int num_dims = 0;
            get_dimensions(dim_list_node, dims, &num_dims);

            int flat_index = 0;
            if (init_val_node->children[0]->num_children > 0)
            { // 如果 {} 不为空
                generate_initializer_stores(init_val_node->children[0], ptr_reg, llvm_type, dims, num_dims, &flat_index);
            }
        }
        else
        { // 简单变量初始化
            char *init_val = generate_code(init_val_node);
            emit("  store %s %s, %s* %s", base_type, init_val, base_type, ptr_reg);
            free(init_val);
        }
    }

    free(llvm_type);
    free(ptr_reg);

    if (n->num_children > 1)

    {
        process_var_def_list(n->children[n->num_children - 1], base_type);
    }
}
// 从维度AST节点中提取维度信息
static void get_dimensions(Node *dim_node, int *dims, int *num_dims)
{
    if (!dim_node || dim_node->num_children == 0)
    {
        return;
    }
    char *dim_str = generate_code(dim_node->children[0]);
    dims[(*num_dims)++] = atoi(dim_str);
    free(dim_str);
    get_dimensions(dim_node->children[1], dims, num_dims);
}

// 核心递归函数，生成初始化存储指令
static void generate_initializer_stores(Node *init_node, char *base_ptr, char *llvm_type, int *dims, int num_dims, int *flat_index)
{
    if (!init_node)
        return;

    // 情况1: 当前初始化项是一个表达式 (例如, 5)
    if (strcmp(init_node->name, "ConstExp") == 0 || strcmp(init_node->name, "Exp") == 0)
    {
        char *val_reg = generate_code(init_node);

        // 计算多维索引
        char gep_indices[256] = "i32 0"; // GEP的第一个索引总是i32 0
        char temp[32];
        int temp_index = *flat_index;
        for (int i = 0; i < num_dims; i++)
        {
            int dim_prod = 1;
            for (int j = i + 1; j < num_dims; j++)
            {
                dim_prod *= dims[j];
            }
            int index_i = temp_index / dim_prod;
            sprintf(temp, ", i32 %d", index_i);
            strcat(gep_indices, temp);
            temp_index %= dim_prod;
        }

        char *element_ptr = new_reg();
        char *element_type = strchr(llvm_type, 'x'); // 粗略获取元素类型
        if (!element_type)
            element_type = "i32";
        else
            element_type += 2; // e.g., from "[10 x i32]" get "i32]"

        char clean_element_type[64];
        sscanf(element_type, "%s", clean_element_type);
        if (strchr(clean_element_type, ']'))
            *strchr(clean_element_type, ']') = '\0';

        emit("  %s = getelementptr inbounds %s, %s* %s, %s", element_ptr, llvm_type, llvm_type, base_ptr, gep_indices);
        emit("  store %s %s, %s* %s", clean_element_type, val_reg, clean_element_type, element_ptr);

        free(val_reg);
        free(element_ptr);
        (*flat_index)++;
    }
    // 情况2: 当前初始化项是另一个列表 (例如, { ... })
    else if (strcmp(init_node->name, "InitVal_Aggregate") == 0)
    {
        generate_initializer_stores(init_node->children[0], base_ptr, llvm_type, dims, num_dims, flat_index);
    }
    // 情况3: 这是一个初始化值列表节点
    else if (strcmp(init_node->name, "ConstInitVal_List") == 0 || strcmp(init_node->name, "InitVal_List") == 0)
    {
        // 先处理当前节点的值
        generate_initializer_stores(init_node->children[0], base_ptr, llvm_type, dims, num_dims, flat_index);
        // 递归处理列表的剩余部分
        if (init_node->num_children > 1)
        {
            generate_initializer_stores(init_node->children[1], base_ptr, llvm_type, dims, num_dims, flat_index);
        }
    }
}

// process_block_item_list: 健壮的、递归处理语句块内条目的函数
static void process_block_item_list(Node *n)
{
    if (!n || n->num_children == 0)
        return;
    generate_code(n->children[0]);
    process_block_item_list(n->children[1]);
}

// 修正：健壮的参数类型列表构建函数
static void process_param_types(Node *n, TypeNode **head_ref)
{
    if (!n || n->num_children == 0)
        return;
    // 先递归，再头插，实现链表反转，得到正确顺序
    if (n->num_children > 1)
        process_param_types(n->children[1], head_ref);
    Node *param_node = n->children[0];
    TypeNode *new_tn = (TypeNode *)malloc(sizeof(TypeNode));
    new_tn->type = strdup(get_type_str(param_node->children[0]));
    new_tn->next = *head_ref;
    *head_ref = new_tn;
}

// 修正：健壮的函数形参处理函数
static void process_formal_params(Node *n, int *count)
{
    if (!n || n->num_children == 0)
        return;
    Node *param_node = n->children[0];
    char *param_type = get_type_str(param_node->children[0]);
    char *param_name = param_node->children[1]->name;
    char param_reg[16];
    snprintf(param_reg, sizeof(param_reg), "%%%d", (*count)++);
    char *ptr_reg = new_reg();
    emit("  %s = alloca %s", ptr_reg, param_type);
    emit("  store %s %s, %s* %s", param_type, param_reg, param_type, ptr_reg);
    add_symbol(param_name, param_type, ptr_reg, 0);
    free(ptr_reg);
    if (n->num_children > 1)
        process_formal_params(n->children[1], count);
}

// 修正：健壮的函数实参处理函数
static void process_actual_params(Node *n, char *arg_reg_list[], int *count)
{
    if (!n || n->num_children == 0)
        return;
    arg_reg_list[(*count)++] = generate_code(n->children[0]);
    if (n->num_children > 1)
        process_actual_params(n->children[1], arg_reg_list, count);
}

// 生成器设置与销毁

static void init_ir_generator()
{
    generator.reg_counter = 0;
    generator.label_counter = 0;
    generator.code_size = 0;
    generator.code_capacity = 1024;
    generator.code_buffer =
        (char **)malloc(generator.code_capacity * sizeof(char *));
    generator.current_scope = NULL;
    generator.current_func_ret_type = NULL;
    generator.last_instr_is_terminator = 0;
    enter_scope();
}

static void free_ir_generator()
{
    while (generator.current_scope)
    {
        exit_scope();
    }
    for (int i = 0; i < generator.code_size; i++)
    {
        free(generator.code_buffer[i]);
    }
    free(generator.code_buffer);
}

static void emit(const char *format, ...)
{
    if (generator.code_size >= generator.code_capacity)
    {
        // 扩容
        generator.code_capacity *= 2;
        generator.code_buffer = (char **)realloc(
            generator.code_buffer, generator.code_capacity * sizeof(char *));
    }
    char temp_buf[1024];
    va_list args;
    va_start(args, format);
    vsnprintf(temp_buf, sizeof(temp_buf), format, args);
    va_end(args);
    generator.code_buffer[generator.code_size++] = strdup(temp_buf);
}

static void write_ir_to_file(const char *filename)
{
    FILE *out = fopen(filename, "w");
    if (!out)
    {
        perror("Could not open output file");
        return;
    }
    for (int i = 0; i < generator.code_size; i++)
    {
        fprintf(out, "%s\n", generator.code_buffer[i]);
    }
    fclose(out);
}

// 公共入口点

void generate_llvm_ir(Node *root, const char *output_filename)
{
    init_ir_generator();
    generate_code(root);
    write_ir_to_file(output_filename);
    free_ir_generator();
}
```